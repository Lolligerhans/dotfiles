#!/bin/false

# NOTE: This file is sourced by bash automatically from ~/.bash_completion. If
#       that did not happen we could source it manually over bashrc.

_supercd_completion() {
  if ((${#COMP_WORDS[@]} != 2)); then return; fi

  #>&2 printf "\n[command] find . -maxdepth 2 -type d -iregex %s\n" ".*${COMP_WORDS[1]}.*";

  # If the -not -path does not stop 'find' from loading large ".git" and similar
  # directories, we could also try using only "*" — without quotes — as path
  # instead of ".". That way at least it doesnt search "./.git".
  declare -a list;
  IFS=$'\n' list=(\
    $(find . -maxdepth 3 -type d -not -path '*/.*' -iregex ".*${COMP_WORDS[1]}.*")\
    );
    #grep ---color=auto -e "git")\

  #>&2 printf "\n[list] {%s}\n" "${list[*]}";

  COMPREPLY=("${list[@]#+(./)}");

  #>&2 printf "\n[reply] {%s}\n" "${COMPREPLY[*]}";
}
# These match the names in .bash_aliases
complete -F _supercd_completion "supercd";
complete -F _supercd_completion ",";

# ╭────────────────────────────────────────────────────────────────────────────╮
# │ Runscripts                                                                 │
# ╰────────────────────────────────────────────────────────────────────────────╯

_runscript_completion() {
  # NOTE:We made sure that the runscript boilerplate outputs on stderr only.
  #      Therefore we can cleanly capture command outputs by suppressing stderr
  #      and capturing stdin.

  declare -r path="${1:-"./run.sh"}"
  declare -r runscript_command="${COMP_WORDS[1]:-""}"
  declare -r to_be_completed="${COMP_WORDS[$COMP_CWORD]}"
  declare gen_command="$runscript_command"
  if [[ "${runscript_command:0:1}" == "-" ]]; then
    gen_command="default"
  fi
  declare -r gen_command
  declare has_completion=""
  # TODO: Move the has_completion command from a command to a function. We do
  #       not want to autocomplete it or users to call it, generally.
  has_completion="$(2>/dev/null "$path" "has_completion" "${gen_command}")"
  declare -r has_completion

  declare IFS=$'\n'

  # Case 1: Complete explicit command arguments. Arguments always start with
  # a dash.
  if [[ "${to_be_completed:0:1}" == "-" ]]; then
    if [[ "$has_completion" == "true" ]]; then
      COMPREPLY=($(compgen -o default -W "$(2>/dev/null "$path" "$gen_command" "--autocomplete")" -- "${to_be_completed}"))
    else
      # NOTE: Important to prevent running a command by accident from the
      #       completion script.
      1>&2 echo "bash_completion: No completion available for command '$gen_command'"
    fi
    return
  fi

  # Case 2: Completing the command itself
  if ((COMP_CWORD == 1)); then
    COMPREPLY=($(compgen -W "$(2>/dev/null "$path" "print_commands")" -- "${to_be_completed}"))
    return
  fi

  if [[ "$runscript_command" == "help" ]]; then
    # The "help" command gets special treatment by always completing by
    # abailable command names.
    COMPREPLY=($(compgen -W "$(2>/dev/null "$path" "print_commands")" -- "${to_be_completed}"))
    return
  fi

  if [[ -z "${to_be_completed}" ]]; then
    COMPREPLY=($(compgen -o default))
    return
  fi

  # Users need to type the first dash manually to enable options completion
  if [[ "$has_completion" == "true" ]]; then
    COMPREPLY=($(compgen -o default -W "$(2>/dev/null "$path" "$gen_command" "--autocomplete")" -- "${to_be_completed}"))
  else
    1>&2 echo "bash_completion: No completion available for command '$gen_command'"
    COMPREPLY=($(compgen -o default -- "$to_be_completed"))
  fi
  # TODO: Complete non-option parameters with paths and files after equals ign "=".
}

_e_completion() { _runscript_completion; }
_q_completion() { _runscript_completion ./run.sh help; }
_E_completion() { _runscript_completion ~/dotfiles/run.sh; }
# TODO: -o fullquote does not work
complete -o nosort -F _e_completion e
complete -o nosort -F _q_completion q
complete -o nosort -F _e_completion ./run.sh
complete -o nosort -F _E_completion E

# Bash completion for some of the aliases specified by dotfiles
_wW_completion() {
  if [ "${#COMP_WORDS[@]}" != "2" ]; then
    return
  fi

  declare flag="${1:-""}"
  declare IFS=$'\n'

  # keep the suggestions in a local variable
  declare word_list
  word_list="$(fc "-${flag}l" -50 | sed -e 's/^[[:blank:]]*//' -e 's/\t/ /g')"

  # Block obsolete because better early processing
  #>&2 echo "WORDLIST [with whitespace] (${#word_list[@]}): [${word_list/+( )/_}]";
  # Replace the leading spaces that fc introduces for no reason
  #word_list="$(sed -ze 's/\n/✖/g' -e 's/✖[[:space:]]*/✖/g' -e 's/✖/\n/g' <<< "$word_list")";
  >&2 echo "WORDLIST [wi/o whitespace] (${#word_list[@]}): [${word_list}]"
  >&2 echo "INPUT comp_words: [${COMP_WORDS[1]}]"

  declare -a suggestions=($(compgen -W "$word_list" -- "${COMP_WORDS[1]}"))

  #>&2 IFS="•" eval 'echo "Raw compgen suggestions [${#suggestions[@]}]:" "${suggestions[*]}"';

  #>&2 echo "(${#suggestions[@]} suggestions)";
  if [ "${#suggestions[@]}" -eq "1" ]; then
    (($# == 0)) &&
      declare number="${suggestions[0]/%% */}" ||
      declare number="${suggestions[0]}"
    #>&2 echo "Using single match: [$number]";
    COMPREPLY=("$number")
    # >&2 IFS="•" eval 'echo "RETURNING: [${COMPREPLY[*]}]"';
  else
    #(( $# == 0 )) && for i in "${!suggestions[@]}"; do
    #  suggestions[$i]="$(printf '%*s' "-$COLUMNS"  "${suggestions[$i]}")"
    #done
    #IFS="•" echo "Suggestions: ${suggestions[*]}";

    COMPREPLY=("${suggestions[@]}")
    #IFS="•";
    #>&2 IFS="•" eval 'echo "RETURNING: [${COMPREPLY[*]}]"';

  fi
}
_w_completion() { _wW_completion; }
_W_completion() { _wW_completion n; }
complete -F _w_completion w
complete -F _W_completion W

# ╭────────────────────────────────────────────────────────────────────────────╮
# │ Git completion                                                             │
# ╰────────────────────────────────────────────────────────────────────────────╯

declare -x GIT_COMPLETION_SHOW_ALL="1" # --allow-empty
declare -x GIT_COMPLETION_IGNORE_CASE="1"

# This file is symlinked by the install script
source ~/.local/share/git-completion.bash
__git_complete a git_add
__git_complete co git_checkout
__git_complete c git_commit
__git_complete C git_commit
__git_complete di git_diff
__git_complete dis git_diff
__git_complete die git_diff

# vim: ft=bash
